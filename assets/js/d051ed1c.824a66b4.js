"use strict";(globalThis.webpackChunkangular_bootcamp=globalThis.webpackChunkangular_bootcamp||[]).push([[7870],{4766:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>b,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"rxjs","title":"RxJS in Angular","description":"RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables, which makes it easier to compose asynchronous or callback-based code. In Angular, RxJS is used extensively for handling asynchronous operations, such as HTTP requests, event handling, and more.","source":"@site/docs/rxjs.md","sourceDirName":".","slug":"/rxjs","permalink":"/angular-bootcamp/docs/rxjs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Dependency Injection in Angular","permalink":"/angular-bootcamp/docs/di"},"next":{"title":"Tutorial - Basics","permalink":"/angular-bootcamp/docs/category/tutorial---basics"}}');var t=s(4848),a=s(8453);const i={sidebar_position:2},l="RxJS in Angular",o={},c=[{value:"RxJS Overview",id:"rxjs-overview",level:2},{value:"Observable-Observer Pattern",id:"observable-observer-pattern",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Example calling an HTTP API",id:"example-calling-an-http-api",level:2},{value:"Operators",id:"operators",level:2},{value:"Subjects",id:"subjects",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rxjs-in-angular",children:"RxJS in Angular"})}),"\n",(0,t.jsx)(n.p,{children:"RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables, which makes it easier to compose asynchronous or callback-based code. In Angular, RxJS is used extensively for handling asynchronous operations, such as HTTP requests, event handling, and more."}),"\n",(0,t.jsx)(n.h2,{id:"rxjs-overview",children:"RxJS Overview"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[Observable] --\x3e|emits data| B[Observer]\n    A --\x3e|transformed by| C[Operators]\n    C --\x3e|chain of operations| B\n    D[Subject] --\x3e|multicasts to| E[Multiple Observers]\n    D --\x3e|types| F[BehaviorSubject]\n    D --\x3e|types| G[ReplaySubject]"}),"\n",(0,t.jsx)(n.h2,{id:"observable-observer-pattern",children:"Observable-Observer Pattern"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant O as Observable\n    participant S as Subscriber\n    O->>S: next(value1)\n    O->>S: next(value2)\n    O->>S: next(value3)\n    O->>S: complete()"}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Observables"}),": A data stream that can emit multiple values over time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Observers"}),": Consumers of the data emitted by Observables."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Operators"}),": Functions that enable functional programming with Observables, allowing you to transform, filter, and combine streams."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subjects"}),": A special type of Observable that allows values to be multicast to multiple Observers."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-calling-an-http-api",children:"Example calling an HTTP API"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ApiService {\n    // 1. Inject HttpClient\n    constructor(private http: HttpClient) {}\n\n    // 2. Create a method that returns an Observable\n    getData(): Observable<any> {\n        return this.http.get('https://api.example.com/data');\n    }\n}\n\n// In a component\nimport { Component, OnInit } from '@angular/core';\nimport { ApiService } from './api.service';\n\n@Component({\n    selector: 'app-example',\n    templateUrl: './example.component.html',\n    styleUrls: ['./example.component.css']\n})\nexport class ExampleComponent implements OnInit {\n    data: any;\n\n    constructor(private apiService: ApiService) {}\n\n    ngOnInit() {\n        this.apiService.getData().subscribe(response => {\n            this.data = response;\n        });\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["what is ",(0,t.jsx)(n.strong,{children:".subscribe()"}),"?\nThe ",(0,t.jsx)(n.code,{children:".subscribe()"})," method is used to subscribe to an Observable in RxJS. When you call ",(0,t.jsx)(n.code,{children:".subscribe()"}),", you are essentially telling the Observable to start emitting values, and you provide a callback function that will be executed each time a new value is emitted.\ncallback in ",(0,t.jsx)(n.code,{children:".subscribe()"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Next Callback"}),": This function is called whenever the Observable emits a new value. You can use this to handle the data received from the Observable. If we only provide one function to ",(0,t.jsx)(n.code,{children:".subscribe()"}),", it will be treated as the next callback."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Callback"}),": This function is called if the Observable encounters an error. You can use this to handle any errors that may occur during the data emission."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complete Callback"}),": This function is called when the Observable has finished emitting all values. You can use this to perform any cleanup or finalization tasks."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"observable.subscribe({\n    next: (value) => {\n        // Handle the emitted value\n    },\n    error: (err) => {\n        // Handle the error\n    },\n    complete: () => {\n        // Handle the completion\n    }\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,t.jsx)(n.p,{children:"RxJS provides a wide range of operators that allow you to manipulate and transform Observables."}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\n    A[Source Observable] --\x3e B[pipe]\n    B --\x3e|transform| C[map]\n    C --\x3e|filter values| D[filter]\n    D --\x3e|switch stream| E[switchMap]\n    E --\x3e F[Final Observable]\n    G[of operator] --\x3e|create| A"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pipe Operator"}),": The ",(0,t.jsx)(n.code,{children:"pipe"})," method is used to combine multiple operators into a single function. This allows you to create a chain of operations that will be applied to the Observable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Map Operator"}),": The ",(0,t.jsx)(n.code,{children:"map"})," operator is used to transform the values emitted by an Observable. It takes a function as an argument that defines how to transform each value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Filter Operator"}),": The ",(0,t.jsx)(n.code,{children:"filter"})," operator is used to filter the values emitted by an Observable. It takes a predicate function as an argument that defines which values should be emitted."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SwitchMap Operator"}),": The ",(0,t.jsx)(n.code,{children:"switchMap"})," operator is used to switch to a new Observable whenever the source Observable emits a value. It is commonly used for handling HTTP requests that depend on previous values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Of Operator"}),": The ",(0,t.jsx)(n.code,{children:"of"})," operator is used to create an Observable that emits a sequence of values."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { map, filter } from 'rxjs/operators';\n\nobservable\n.pipe(\n    map((value) => value * 2),\n    filter((value) => value > 10)    \n).subscribe((value) => {\n    // Handle the transformed value\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"SwitchMap example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { switchMap } from 'rxjs/operators';\n\nobservable\n.pipe(\n    switchMap((id) => this.http.get(`api/user/${id}`)),\n    switchMap((user) => {\n        if (user.isActive) {\n            return this.http.get(`api/user/${user.id}/details`);\n        } else {\n            return of(null); // Return an observable with null if user is not active\n        }\n    }),\n).subscribe((details) => {\n    console.log(details);// if user is not active, details will be null\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"subjects",children:"Subjects"}),"\n",(0,t.jsx)(n.p,{children:"Subjects are a special type of Observable that allows values to be multicast to multiple Observers. They can be used to create event emitters, manage state, and more."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant S as Subject\n    participant BS as BehaviorSubject\n    participant RS as ReplaySubject\n    participant O1 as Observer 1\n    participant O2 as Observer 2\n    \n    Note over S: No initial value\n    O1->>S: Subscribe\n    S->>O1: Receives new values\n    O2->>S: Subscribe\n    S->>O2: Only future values\n    \n    Note over BS: Has initial value\n    O1->>BS: Subscribe\n    BS->>O1: Gets initial/last value\n    O2->>BS: Subscribe\n    BS->>O2: Gets last value\n    \n    Note over RS: Replays previous values\n    O1->>RS: Subscribe\n    RS->>O1: Gets all previous values\n    O2->>RS: Subscribe\n    RS->>O2: Gets all previous values"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subject"}),": A Subject is an Observable that can also act as an Observer. It allows you to multicast values to multiple Observers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BehaviorSubject"}),": A BehaviorSubject is an Observable that emits the ",(0,t.jsx)(n.strong,{children:"last value"})," emitted by the source Observable, or a default value if no values have been emitted yet."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ReplaySubject"}),": A ReplaySubject is an Observable that emits all values emitted by the source Observable, or a default value if no values have been emitted yet."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Subject } from 'rxjs';\nconst subject = new Subject<number>();\nsubject.subscribe((value) => {\n    console.log('Observer A:', value);\n});\n\nsubject.next(1);\n\nsubject.subscribe((value) => {\n    console.log('Observer B:', value);\n});\nsubject.next(2);\n\n// Output:\n// Observer A: 1\n// Observer A: 2\n// Observer B: 2\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { BehaviorSubject } from 'rxjs';\nconst behaviorSubject = new BehaviorSubject<number>(0); // initial value is 0\nbehaviorSubject.subscribe((value) => {\n    console.log('Observer A:', value);\n});\n\nbehaviorSubject.next(1);\nbehaviorSubject.next(2);\nbehaviorSubject.subscribe((value) => {\n    console.log('Observer B:', value);\n});\nbehaviorSubject.next(3);\n// Output:\n// Observer A: 0\n// Observer A: 1\n// Observer A: 2\n// Observer B: 2\n// Observer A: 3\n// Observer B: 3\n"})})]})}function b(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var r=s(6540);const t={},a=r.createContext(t);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);