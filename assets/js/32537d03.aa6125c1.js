"use strict";(globalThis.webpackChunkangular_bootcamp=globalThis.webpackChunkangular_bootcamp||[]).push([[2566],{8453:(t,e,r)=>{r.d(e,{R:()=>s,x:()=>a});var n=r(6540);const i={},o=n.createContext(i);function s(t){const e=n.useContext(o);return n.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:s(t.components),n.createElement(o.Provider,{value:e},t.children)}},9191:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"form","title":"Angular Forms","description":"have two types of form in Angular (one more in the future with Signal based form)","source":"@site/docs/form.md","sourceDirName":".","slug":"/form","permalink":"/angular-bootcamp/docs/form","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Angular Pipe","permalink":"/angular-bootcamp/docs/pipe"}}');var i=r(4848),o=r(8453);const s={sidebar_position:5},a="Angular Forms",d={},l=[{value:"Template-driven Form",id:"template-driven-form",level:2},{value:"Reactive Form",id:"reactive-form",level:2},{value:"Nested Forms",id:"nested-forms",level:2}];function m(t){const e={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"angular-forms",children:"Angular Forms"})}),"\n",(0,i.jsx)(e.p,{children:"have two types of form in Angular (one more in the future with Signal based form)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Template-driven form"}),"\n",(0,i.jsx)(e.li,{children:"Reactive form"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"template-driven-form",children:"Template-driven Form"}),"\n",(0,i.jsxs)(e.p,{children:["Basic, easy to use, less code in component class, suitable for simple form with less validation logic.\nUse ",(0,i.jsx)(e.strong,{children:"ngModel"})," to create two-way data bindings for reading and writing input-control values."]}),"\n",(0,i.jsx)(e.p,{children:"Here's an example of a template-driven form with email validation:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// email-form.component.ts\nimport { Component } from "@angular/core"\nimport { NgForm } from "@angular/forms"\n\n@Component({\n\tselector: "app-email-form",\n\ttemplateUrl: "./email-form.component.html",\n})\nexport class EmailFormComponent {\n\tuserEmail = "" // This will hold our email value\n\n\tonSubmit(form: NgForm) {\n\t\tif (form.valid) {\n\t\t\tconsole.log("Email submitted:", this.userEmail)\n\t\t}\n\t}\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- email-form.component.html --\x3e\n<form #emailForm="ngForm" (ngSubmit)="onSubmit(emailForm)">\n\t<div>\n\t\t<label for="email">Email:</label>\n\t\t<input\n\t\t\ttype="email"\n\t\t\tid="email"\n\t\t\tname="email"\n\t\t\t[(ngModel)]="userEmail"\n\t\t\t#email="ngModel"\n\t\t\trequired\n\t\t\temail\n\t\t/>\n\n\t\t\x3c!-- Show validation messages --\x3e\n\t\t<div *ngIf="email.invalid && (email.dirty || email.touched)">\n\t\t\t<div *ngIf="email.errors?.[\'required\']">Email is required</div>\n\t\t\t<div *ngIf="email.errors?.[\'email\']">\n\t\t\t\tPlease enter a valid email address\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<button type="submit" [disabled]="emailForm.invalid">Submit</button>\n</form>\n'})}),"\n",(0,i.jsxs)(e.p,{children:["Remember to import ",(0,i.jsx)(e.code,{children:"FormsModule"})," in your module:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'import { NgModule } from "@angular/core"\nimport { FormsModule } from "@angular/forms"\n\n@NgModule({\n\timports: [\n\t\tFormsModule, // Add this to enable template-driven forms\n\t],\n\t// ...\n})\nexport class AppModule {}\n'})}),"\n",(0,i.jsx)(e.p,{children:"This example demonstrates:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Two-way data binding with ",(0,i.jsx)(e.code,{children:"[(ngModel)]"})]}),"\n",(0,i.jsxs)(e.li,{children:["Form validation with ",(0,i.jsx)(e.code,{children:"required"})," and ",(0,i.jsx)(e.code,{children:"email"})," validators"]}),"\n",(0,i.jsx)(e.li,{children:"Error messages using template variables"}),"\n",(0,i.jsx)(e.li,{children:"Form submission handling"}),"\n",(0,i.jsx)(e.li,{children:"Disable submit button when form is invalid"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"reactive-form",children:"Reactive Form"}),"\n",(0,i.jsxs)(e.p,{children:["More powerful and scalable, suitable for complex forms with dynamic validation logic.\nUses ",(0,i.jsx)(e.code,{children:"FormControl"}),", ",(0,i.jsx)(e.code,{children:"FormGroup"}),", and ",(0,i.jsx)(e.code,{children:"FormBuilder"})," to create form controls in the component class."]}),"\n",(0,i.jsx)(e.p,{children:"Here's an example of a Reactive Form for user information:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// user.interface.ts\nexport interface User {\n\tuserId?: number\n\tfirstName: string\n\tlastName: string\n}\n\n// user-form.component.ts\nimport { Component, OnInit } from "@angular/core"\nimport { FormBuilder, FormGroup, Validators } from "@angular/forms"\nimport { User } from "./user.interface"\n\n@Component({\n\tselector: "app-user-form",\n\ttemplateUrl: "./user-form.component.html",\n})\nexport class UserFormComponent implements OnInit {\n\tuserForm: FormGroup\n\n\tconstructor(private fb: FormBuilder) {}\n\n\tngOnInit() {\n\t\tthis.userForm = this.fb.group({\n\t\t\tuserId: [""], // optional field\n\t\t\tfirstName: ["", [Validators.required, Validators.minLength(2)]],\n\t\t\tlastName: ["", [Validators.required, Validators.minLength(2)]],\n\t\t})\n\t}\n\n\t// Getter methods for easy access in template\n\tget firstName() {\n\t\treturn this.userForm.get("firstName")\n\t}\n\tget lastName() {\n\t\treturn this.userForm.get("lastName")\n\t}\n\n\tonSubmit() {\n\t\tif (this.userForm.valid) {\n\t\t\tconst user: User = this.userForm.value\n\t\t\tconsole.log("User submitted:", user)\n\t\t}\n\t}\n\n\t// Optional: Load existing user data\n\tloadUser(user: User) {\n\t\tthis.userForm.patchValue(user)\n\t}\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- user-form.component.html --\x3e\n<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n\t<div>\n\t\t<label for="firstName">First Name:</label>\n\t\t<input id="firstName" type="text" formControlName="firstName" />\n\t\t<div *ngIf="firstName?.invalid && (firstName?.dirty || firstName?.touched)">\n\t\t\t<div *ngIf="firstName?.errors?.[\'required\']">First name is required</div>\n\t\t\t<div *ngIf="firstName?.errors?.[\'minlength\']">\n\t\t\t\tFirst name must be at least 2 characters\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<div>\n\t\t<label for="lastName">Last Name:</label>\n\t\t<input id="lastName" type="text" formControlName="lastName" />\n\t\t<div *ngIf="lastName?.invalid && (lastName?.dirty || lastName?.touched)">\n\t\t\t<div *ngIf="lastName?.errors?.[\'required\']">Last name is required</div>\n\t\t\t<div *ngIf="lastName?.errors?.[\'minlength\']">\n\t\t\t\tLast name must be at least 2 characters\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<button type="submit" [disabled]="userForm.invalid">Submit</button>\n</form>\n'})}),"\n",(0,i.jsxs)(e.p,{children:["Remember to import ",(0,i.jsx)(e.code,{children:"ReactiveFormsModule"})," in your module:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'import { NgModule } from "@angular/core"\nimport { ReactiveFormsModule } from "@angular/forms"\n\n@NgModule({\n\timports: [\n\t\tReactiveFormsModule, // Add this to enable reactive forms\n\t],\n\t// ...\n})\nexport class AppModule {}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Key features demonstrated:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Form initialization using ",(0,i.jsx)(e.code,{children:"FormBuilder"})]}),"\n",(0,i.jsx)(e.li,{children:"Form validation with built-in validators"}),"\n",(0,i.jsx)(e.li,{children:"Getter methods for cleaner template code"}),"\n",(0,i.jsx)(e.li,{children:"Error handling and display"}),"\n",(0,i.jsx)(e.li,{children:"Type-safe form submission with interface"}),"\n",(0,i.jsxs)(e.li,{children:["Optional data loading with ",(0,i.jsx)(e.code,{children:"patchValue"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"nested-forms",children:"Nested Forms"}),"\n",(0,i.jsx)(e.p,{children:"Here's an example of composing forms using separate components with interfaces:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// interfaces/address.interface.ts\nexport interface Address {\n\tstreet: string\n\tcity: string\n\tzipCode: string\n}\n\n// interfaces/user.interface.ts\n// Base user information\nexport interface User {\n\tuserId?: number\n\tfirstName: string\n\tlastName: string\n}\n\n// interfaces/user-address.interface.ts\nimport { User } from "./user.interface"\nimport { Address } from "./address.interface"\n\n// Option 1: Composition using intersection type\nexport type UserWithAddress = User & {\n\taddress: Address\n}\n\n// Option 2: Interface extension\nexport interface UserAddress extends User {\n\taddress: Address\n}\n\n// Option 3: Composition with nested interface\nexport interface UserProfile {\n\tuser: User\n\taddress: Address\n}\n\n// components/address-form/address-form.component.ts\nimport { Component, OnInit } from "@angular/core"\nimport {\n\tFormBuilder,\n\tFormGroup,\n\tValidators,\n\tFormGroupDirective,\n} from "@angular/forms"\n\n@Component({\n\tselector: "app-address-form",\n\ttemplateUrl: "./address-form.component.html",\n})\nexport class AddressFormComponent implements OnInit {\n\t// We\'ll bind to the parent\'s \'address\' FormGroup instead of creating a new one\n\taddressForm: FormGroup\n\n\tconstructor(\n\t\tprivate fb: FormBuilder,\n\t\tprivate parentForm: FormGroupDirective\n\t) {}\n\n\tngOnInit() {\n\t\t// Option 1: Bind to existing parent FormGroup\n\t\tconst parentGroup = this.parentForm.form.get("address") as FormGroup\n\t\tthis.addressForm = parentGroup\n\t\t// Ensure controls exist on the parent group (in case parent initialized empty group)\n\t\tif (!this.addressForm.get("street")) {\n\t\t\tthis.addressForm.addControl(\n\t\t\t\t"street",\n\t\t\t\tthis.fb.control("", Validators.required)\n\t\t\t)\n\t\t}\n\t\tif (!this.addressForm.get("city")) {\n\t\t\tthis.addressForm.addControl(\n\t\t\t\t"city",\n\t\t\t\tthis.fb.control("", Validators.required)\n\t\t\t)\n\t\t}\n\t\tif (!this.addressForm.get("zipCode")) {\n\t\t\tthis.addressForm.addControl(\n\t\t\t\t"zipCode",\n\t\t\t\tthis.fb.control("", [\n\t\t\t\t\tValidators.required,\n\t\t\t\t\tValidators.pattern("^[0-9]{5}$"),\n\t\t\t\t])\n\t\t\t)\n\t\t}\n\n\t\t//// Option 2: Or initialize a new address FormGroup then add to new formGroup to parent\n\t\t// this.addressForm = this.fb.group({\n\t\t// street: [\'\', Validators.required],\n\t\t// city: [\'\', Validators.required],\n\t\t// zipCode: [\'\', [Validators.required, Validators.pattern(\'^[0-9]{5}$\')]]\n\t\t// });\n\t\t//// Add address form to parent form\n\t\t// this.parentForm.form.addControl(\'address\', this.addressForm);\n\t}\n\n\t// Getter methods for template access\n\tget street() {\n\t\treturn this.addressForm.get("street")\n\t}\n\tget city() {\n\t\treturn this.addressForm.get("city")\n\t}\n\tget zipCode() {\n\t\treturn this.addressForm.get("zipCode")\n\t}\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- components/address-form/address-form.component.html --\x3e\n<div [formGroup]="addressForm">\n\t<div>\n\t\t<label for="street">Street:</label>\n\t\t<input id="street" type="text" formControlName="street" />\n\t\t<div *ngIf="street?.invalid && (street?.dirty || street?.touched)">\n\t\t\t<div *ngIf="street?.errors?.[\'required\']">Street is required</div>\n\t\t</div>\n\t</div>\n\n\t<div>\n\t\t<label for="city">City:</label>\n\t\t<input id="city" type="text" formControlName="city" />\n\t\t<div *ngIf="city?.invalid && (city?.dirty || city?.touched)">\n\t\t\t<div *ngIf="city?.errors?.[\'required\']">City is required</div>\n\t\t</div>\n\t</div>\n\n\t<div>\n\t\t<label for="zipCode">ZIP Code:</label>\n\t\t<input id="zipCode" type="text" formControlName="zipCode" />\n\t\t<div *ngIf="zipCode?.invalid && (zipCode?.dirty || zipCode?.touched)">\n\t\t\t<div *ngIf="zipCode?.errors?.[\'required\']">ZIP code is required</div>\n\t\t\t<div *ngIf="zipCode?.errors?.[\'pattern\']">ZIP code must be 5 digits</div>\n\t\t</div>\n\t</div>\n</div>\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// components/user-profile-form/user-profile-form.component.ts\nimport { Component, OnInit } from "@angular/core"\nimport { FormBuilder, FormGroup, Validators } from "@angular/forms"\nimport { User } from "../../interfaces/user.interface"\nimport {\n\tUserWithAddress,\n\tUserAddress,\n\tUserProfile,\n} from "../../interfaces/user-address.interface"\n\n@Component({\n\tselector: "app-user-profile-form",\n\ttemplateUrl: "./user-profile-form.component.html",\n})\nexport class UserProfileFormComponent implements OnInit {\n\tuserProfileForm: FormGroup\n\n\tconstructor(private fb: FormBuilder) {}\n\n\tngOnInit() {\n\t\tthis.userProfileForm = this.fb.group({\n\t\t\tuserId: [""],\n\t\t\tfirstName: ["", [Validators.required, Validators.minLength(2)]],\n\t\t\tlastName: ["", [Validators.required, Validators.minLength(2)]],\n\t\t\taddress: this.fb.group({}), // Address form group will be created in child component\n\t\t})\n\t}\n\n\tget firstName() {\n\t\treturn this.userProfileForm.get("firstName")\n\t}\n\tget lastName() {\n\t\treturn this.userProfileForm.get("lastName")\n\t}\n\n\tonSubmit() {\n\t\tif (this.userProfileForm.valid) {\n\t\t\t// Option 1: Using UserWithAddress type\n\t\t\tconst userWithAddress: UserWithAddress = this.userProfileForm.value\n\t\t\tconsole.log("User Profile submitted (UserWithAddress):", userWithAddress)\n\n\t\t\t// You can also transform between formats if needed\n\t\t\tconst transformToUserProfile: UserProfile = {\n\t\t\t\tuser: {\n\t\t\t\t\tuserId: userWithAddress.userId,\n\t\t\t\t\tfirstName: userWithAddress.firstName,\n\t\t\t\t\tlastName: userWithAddress.lastName,\n\t\t\t\t},\n\t\t\t\taddress: userWithAddress.address,\n\t\t\t}\n\t\t}\n\t}\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- components/user-profile-form/user-profile-form.component.html --\x3e\n<form [formGroup]="userProfileForm" (ngSubmit)="onSubmit()">\n\t<div>\n\t\t<label for="firstName">First Name:</label>\n\t\t<input id="firstName" type="text" formControlName="firstName" />\n\t\t<div *ngIf="firstName?.invalid && (firstName?.dirty || firstName?.touched)">\n\t\t\t<div *ngIf="firstName?.errors?.[\'required\']">First name is required</div>\n\t\t\t<div *ngIf="firstName?.errors?.[\'minlength\']">\n\t\t\t\tFirst name must be at least 2 characters\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<div>\n\t\t<label for="lastName">Last Name:</label>\n\t\t<input id="lastName" type="text" formControlName="lastName" />\n\t\t<div *ngIf="lastName?.invalid && (lastName?.dirty || lastName?.touched)">\n\t\t\t<div *ngIf="lastName?.errors?.[\'required\']">Last name is required</div>\n\t\t\t<div *ngIf="lastName?.errors?.[\'minlength\']">\n\t\t\t\tLast name must be at least 2 characters\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t\x3c!-- Address Form Component --\x3e\n\t<div formGroupName="address">\n\t\t<h3>Address</h3>\n\t\t<app-address-form></app-address-form>\n\t</div>\n\n\t<button type="submit" [disabled]="userProfileForm.invalid">Submit</button>\n</form>\n'})}),"\n",(0,i.jsx)(e.p,{children:"Key features of this implementation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Separate interfaces for User and Address"}),"\n",(0,i.jsx)(e.li,{children:"Reusable AddressForm component"}),"\n",(0,i.jsx)(e.li,{children:"Proper form group nesting"}),"\n",(0,i.jsx)(e.li,{children:"Validation at both parent and child levels"}),"\n",(0,i.jsx)(e.li,{children:"Type safety with interfaces"}),"\n",(0,i.jsx)(e.li,{children:"Clean separation of concerns"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Note on parent binding approaches:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["Constructor injection (used in the ",(0,i.jsx)(e.code,{children:"AddressFormComponent"})," above):"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["We inject ",(0,i.jsx)(e.code,{children:"FormGroupDirective"})," in the child's constructor: ",(0,i.jsx)(e.code,{children:"constructor(private fb: FormBuilder, private parentForm: FormGroupDirective)"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["The child component then reads ",(0,i.jsx)(e.code,{children:"this.parentForm.form.get('address')"})," and binds to that FormGroup. This is explicit and works well when you want to directly manipulate or ensure controls exist on the parent group."]}),"\n",(0,i.jsx)(e.li,{children:"Pros: Explicit, easy to reason about, works well with DI and unit tests."}),"\n",(0,i.jsx)(e.li,{children:"Cons: Child depends on being used inside a parent form; you'll get runtime errors if used standalone unless you add fallbacks (as shown)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"viewProviders / ControlContainer approach (earlier example):"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Uses ",(0,i.jsx)(e.code,{children:"viewProviders"})," to provide the ",(0,i.jsx)(e.code,{children:"ControlContainer"})," to the child so the child template can use relative form directives without manually grabbing the parent form instance."]}),"\n",(0,i.jsx)(e.li,{children:"Pros: Cleaner templates and decouples the child from parent implementation details."}),"\n",(0,i.jsx)(e.li,{children:"Cons: Slightly more magical; harder to unit-test the child in complete isolation without wiring a host form."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Choose the approach that fits your team's preference and test strategy. For strict explicitness and easier testability, constructor-injected ",(0,i.jsx)(e.code,{children:"FormGroupDirective"})," is a solid choice. For cleaner templates and looser coupling, ",(0,i.jsx)(e.code,{children:"viewProviders"})," + ",(0,i.jsx)(e.code,{children:"ControlContainer"})," is convenient."]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.p,{children:"Flat-composition examples (UserWithAddress)"}),"\n",(0,i.jsxs)(e.p,{children:["Below are two separate examples that implement the flat ",(0,i.jsx)(e.code,{children:"UserWithAddress"})," type. Both create a parent form with an ",(0,i.jsx)(e.code,{children:"address"})," FormGroup and show two ways the child ",(0,i.jsx)(e.code,{children:"AddressFormComponent"})," can bind to that group."]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"viewProviders / ControlContainer (clean template, child uses relative directives)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// components/address-form-via-controlcontainer/address-form-via-controlcontainer.component.ts\nimport { Component } from "@angular/core"\nimport { FormBuilder, FormGroup, Validators } from "@angular/forms"\nimport { ControlContainer, FormGroupDirective } from "@angular/forms"\n\n@Component({\n\tselector: "app-address-form-cc",\n\ttemplateUrl: "./address-form-cc.component.html",\n\tviewProviders: [\n\t\t{ provide: ControlContainer, useExisting: FormGroupDirective },\n\t],\n})\nexport class AddressFormViaControlContainerComponent {\n\t// no constructor injection of parent form necessary\n\tconstructor(private fb: FormBuilder) {}\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- components/address-form-via-controlcontainer/address-form-cc.component.html --\x3e\n\x3c!-- Child uses relative formControlName bindings because ControlContainer is provided --\x3e\n<div>\n\t<label>Street</label>\n\t<input formControlName="street" />\n\t<label>City</label>\n\t<input formControlName="city" />\n\t<label>ZIP</label>\n\t<input formControlName="zipCode" />\n</div>\n'})}),"\n",(0,i.jsx)(e.p,{children:"Parent usage:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// parent component that uses flat UserWithAddress\nthis.userProfileForm = this.fb.group({\n\tuserId: [""],\n\tfirstName: ["", Validators.required],\n\tlastName: ["", Validators.required],\n\taddress: this.fb.group({\n\t\tstreet: ["", Validators.required],\n\t\tcity: ["", Validators.required],\n\t\tzipCode: ["", [Validators.required, Validators.pattern("^[0-9]{5}$")]],\n\t}),\n})\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- parent template --\x3e\n<form [formGroup]="userProfileForm">\n\t\x3c!-- user fields --\x3e\n\t<div formGroupName="address">\n\t\t<app-address-form-cc></app-address-form-cc>\n\t</div>\n</form>\n'})}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsx)(e.li,{children:"Constructor-injected FormGroupDirective (explicit access)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// components/address-form-via-parent/address-form-via-parent.component.ts\nimport { Component, OnInit } from "@angular/core"\nimport {\n\tFormBuilder,\n\tFormGroup,\n\tValidators,\n\tFormGroupDirective,\n} from "@angular/forms"\n\n@Component({\n\tselector: "app-address-form-parent",\n\ttemplateUrl: "./address-form-parent.component.html",\n})\nexport class AddressFormViaParentComponent implements OnInit {\n\taddressForm: FormGroup\n\n\tconstructor(\n\t\tprivate fb: FormBuilder,\n\t\tprivate parentForm: FormGroupDirective\n\t) {}\n\n\tngOnInit() {\n\t\tconst parentGroup = this.parentForm.form.get("address") as FormGroup\n\t\tif (parentGroup) {\n\t\t\tthis.addressForm = parentGroup\n\t\t} else {\n\t\t\tthis.addressForm = this.fb.group({\n\t\t\t\tstreet: ["", Validators.required],\n\t\t\t\tcity: ["", Validators.required],\n\t\t\t\tzipCode: ["", [Validators.required, Validators.pattern("^[0-9]{5}$")]],\n\t\t\t})\n\t\t}\n\t}\n}\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'\x3c!-- components/address-form-via-parent/address-form-parent.component.html --\x3e\n<div [formGroup]="addressForm">\n\t<label>Street</label>\n\t<input formControlName="street" />\n\t<label>City</label>\n\t<input formControlName="city" />\n\t<label>ZIP</label>\n\t<input formControlName="zipCode" />\n</div>\n'})}),"\n",(0,i.jsxs)(e.p,{children:["Parent usage is identical to the viewProviders example: place the child inside a parent ",(0,i.jsx)(e.code,{children:'formGroupName="address"'})," container. The difference is the child explicitly reads the parent form instance in code."]}),"\n",(0,i.jsx)(e.p,{children:"Which to choose"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use viewProviders/ControlContainer when you prefer cleaner child templates and looser coupling."}),"\n",(0,i.jsx)(e.li,{children:"Use FormGroupDirective injection when you want explicit control and easier programmatic manipulation of the parent group (adding controls dynamically, setting validators from the child, etc.)."}),"\n"]})]})}function c(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(m,{...t})}):m(t)}}}]);